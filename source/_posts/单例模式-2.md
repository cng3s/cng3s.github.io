---
title: 单例模式-2
date: 2020-03-26 19:47:18
tags: 设计模式
---
# 懒汉单例模式进阶 - jvm指令重排优化埋下的隐患
> 这个问题有一定概率会发生，但不容易复现，所以只能介绍下这个问题的原因和如何解决的。  
首先还是给出上节线程安全且高效的懒汉单例模式实现：
```
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    public static LazySingleton getInstance() {
        if (lazySingleton == null) {
            synchronized (LazySingleton.class) {
                if (lazySingleton == null) {
                    lazySingleton = new LazySingleton();
                }
            }
        }
        return lazySingleton;
    }
}
```
这个隐患是在: if (lazySingleton == null) { lazySingleton = new LazyDoubleCheckSingleton(); }  
隐患导致的问题:  
lazySingleton在其他线程中正在创建，但是没有创建完毕，而此时lazySingleton != null;   
导致了return lazySingleton;的对象可能是有残缺的对象。且其他的线程使用了这个残缺的对象。  
至于为什么会未初始化完成对象，而lazySingleton != null，就是由于jvm的指令重排优化。下面来介绍它。   

lazySingleton = new LazySingleton()所执行的所有操作（按正常指令顺序进行）：  
1. 分配内存给这个对象；
2. 初始化对象；
3. 设置lazySingleton指向刚分配的对象;

这里第2步和第3步可能会被优化重排序，于是即变成了以下顺序：  
1. 分配内存给这个对象；
2. 设置lazySingleton指向刚分配的对象;
(这时lazySingleton != null但还没有完成初始化，而其他线程恰巧在这个时间点使用了这个lazySingleton。出现问题。)  
3. 初始化对象；
导致了lazySingleton != null 但是却还没有初始化完成的情况发生，也就解释了隐患1为什么会出现。  
这个隐患是jvm优化指令重排而导致的问题。  
解决方案有两种：  
1. 不允许2、3进行重排序，即是添加volatile关键字，该关键字保证了初始化对象和对象赋值给lazySingleton的顺序性;  
2. 允许2、3进行重排序，但不允许其他线程看到重排序，这又有两种实现方法：
   1. 全部加上synchronized关键字,但带来了效率问题
   2. 接下来将要介绍的使用静态内部类的单例模式（同样也是懒汉模式）

### 小扩展：
java语言规范保证intra-thread semantics原则，即单线程下指令重排不会改变单线程指令执行结果  
所以2/3互换位置在单线程下是符合这一原则的。但多线程就会出现问题。  
至于为什么jvm要做这个优化，我**猜测**应该是提前将对象赋给lazySingleton可以一边执行接下来的程序步骤，一边进行对象的初始化操作，有更高的并行度。  

第一种解决方案 - 添加volatile关键字的版本 v0.4:
```
public class LazySingleton {

    private volatile static LazySingleton lazySingleton = null;

    public static LazySingleton getInstance() {
        if (lazySingleton == null) {
            synchronized (LazySingleton.class) {
                if (lazySingleton == null) {
                    lazySingleton = new LazySingleton();
                }
            }
        }
        return lazySingleton;
    }
}
```


# 使用静态内部类实现的懒汉单例模式
使用静态内部类实现的懒汉单例模式 v0.4:
```
public class StaticInnerClassSingleton {

    private static class InnerClass {
        private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton();
    }

    public static StaticInnerClassSingleton getInstance() {
        return InnerClass.staticInnerClassSingleton;
    }

    // Singleton模式必须要有 private 的构造器，否则默认为default（也就是package权限），同一个包的外部类可以new出来
    private StaticInnerClassSingleton() {
    }
}
```
该实现的优点如下：
1. 该Singleton对象是懒汉式的，且线程安全，效率好。
2. 假设某线程调用了未初始化的StaticInnerClassSingleton类，则类会因调用进行初始化，且在**初始化时加载Class对象的初始化锁**。就保证了多个线程的初始化线程安全。
其中第二点就是关键，因为初始化时加载Class对象的初始化锁而保证了线程安全，也避免了jvm指令重排导致的隐患。  
而Class初始化又做了如下几个工作：
1. 分配对象的内存空间
2. 设置instance指向内存空间
3. 初始化对象
注意，这里jvm还是进行指令重排了，但因为锁的存在，对于外部来说是不可见的，也是不可访问的。保证了线程安全。

### 小扩展
初始化一个类，包括这个类中的静态类或静态变量的初始化，主要有5种情况导致一个类 A 将被初始化； （注：这里类是泛指，也包含了接口）
1. 有一个 A 类型的实例被创建；
2. A类中的一个静态方法被调用；
3. A类中静态成员被赋值；
4. A类中的静态成员被使用并且这个成员不是一个常量（const）成员；
5. A类是个顶级类并且类A中有嵌套的断言语句，则会被立即初始化（不常用）

# 下节预告
现在仍然不是完美的单例模式，但到这里已经非常不错了。  
接下来要讨论如何保证序列化和反序列化所创建的对象相同，以及，如何避免反射攻击。