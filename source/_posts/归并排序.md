---
title: 归并排序
date: 2020-03-26 19:49:17
tags: 算法
---
# 归并排序算法

## 未优化的基本代码实现
```
void merge(T arr[], int lo, int mi, int hi)
{
    int *tmparr = new int[hi-lo+1];
    for (k = lo; k <= hi; ++k)
        tmparr[tmpidx] = arr[k];
    for (i = lo, j = mi+1, k = lo; i <= mid && j <= hi; ++k) {
        if (tmparr[i-l] < tmparr[j-l]) {
            arr[k] = tmparr[i-lo];
			++i;
		} else {
            arr[k] = tmparr[j-lo];
			++k;
		}
    }
    while (i <= mi) { arr[k++] = tmparr[i-lo]; ++i; }
    while (j <= hi) { arr[k++] = tmparr[j-lo]; ++j; }
    delete[] tmparr;
}

void merge_sort(T arr[], int lo, int hi)
{
    if (lo >= hi)
        return;

    mi = (lo>>1)+(hi>>1);
    merge_sort(arr, lo, mi);
    merge_sort(arr, mi+1, hi);
    merge(arr, lo, mi, hi);
}

void merge_sort(T arr[], int n)
{
    merge_sort(arr, 0, n-1);
}
```

***
## 归并排序代码优化
1. 几乎有序的情况
   近乎有序的情况下，归并排序算法效率要差于插入排序算法。原因在于该情况下插排时间复杂度接近O(n)，而归并为O(nlogn)。
   优化思路是既然归并排序的两个部分arr[lo, mi], arr[mi+1, hi]都是有序的，那么只要符合条件 **arr[mi]>arr[mi+1]** 再进行排序就可以避免不必要的merge操作。于是有了如下改进代码：
```
void merge_sort(T arr[], int lo, int hi)
{
	if (lo >= hi)
        return;

    mi = (lo>>1)+(hi>>1);
    merge_sort(arr, lo, mi);
    merge_sort(arr, mi+1, hi);
    if (arr[mi] > arr[mi+1])
        merge(arr, lo, mi, hi);
}
```
2. arr元素个数很小的情况
   在元素很小的情况下，任何排序算法都不如插排，所以在元素个数很小的情况下，转为插入排序算法。假设元素个数<=16的情况属于元素个数很小的情况。于是改进代码如下：
```
void insertion_sort(T arr[], int lo, int hi)
{
    for (i = lo+1; i <= hi; ++i) {
        T e = arr[i];
        for (j = i; j > 0 && arr[j-1] > e; --j)
            arr[j] = arr[j-1];
        arr[j] = e;
    }
}

void merge_sort(T arr[], int lo, int hi)
{
	if (hi-lo <= 15) {
		insertion_sort(arr, lo, hi);
		return;
	}

    mi = (lo>>1)+(hi>>1);
    merge_sort(arr, lo, mi);
    merge_sort(arr, mi+1, hi);
	if (arr[mi] > arr[mi+1])
    	merge(arr, lo, mi, hi);
}
```
到此为止，比较关于归并排序最常用的优化方法已经介绍完毕。

***
## 归并排序的迭代实现
 **根据统计迭代实现的归并排序效率略低于递归排序**
下面给出未进行优化的迭代归并排序：
```
void merge_sort_iter(T arr[], int n)
{
    for (int sz = 1; sz <= n; sz <<= 1) {
        for (int i = 0; i+sz < n; i += sz+sz)
            // 对 arr[i, i+sz-1] 和 arr[i+sz, i+2*sz-1] 进行归并
            // min(i+sz+sz-1, n-1)来确定数组边界，防止越界
            merge(arr, i, i+sz-1, min(i+sz+sz-1, n-1));
    }
}
```