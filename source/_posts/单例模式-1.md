---
title: 单例模式-1
date: 2020-03-26 19:46:40
tags: 设计模式
---
# 单例模式
定义：保证一个类仅有一个实例，并提供一个全局访问点  
类型：创建型  
场景：想确保任何情况下都绝对只有一个实例，比如一个程序只有一个线程池等  
优点：
* 内存里只有一个实例，减少内存开销
* 避免对资源多重占用
* 设置全局访问点，严格控制访问
缺点：
* 没有接口，扩展困难

## 要点：
1. 私有的构造器
2. 线程安全 - 非常重要*
3. 是否延迟加载 - 是：懒汉式单例模式；否：饿汉式代理模式
4. 序列化和反序列化安全
5. 反射 - 了解如何防止反射攻击
其中：2/3两点是重点，4/5两点是难点。下面会逐步介绍。
本节只详细介绍2/3两个问题。


# 饿汉式单例模式
> 程序初始化时就创建单例模式。  
* 优点：实现简单，由于程序初始化时就创建单例模式，所以不会带来线程安全问题，而懒汉式单例模式需要考虑线程安全
* 缺点：资源可能被浪费，程序创建了该单例模式但从未被使用，可以被反射攻击，序列化/反序列化不安全

最简单的版本v0.1：
```
public class HungrySingleton {

    // 创建方法1：
    // private final static HungrySingleton hungrySingleton = new HungrySingleton();

    // 创建方法2：
    private final static HungrySingleton hungrySingleton;
    static {
        hungrySingleton = new HungrySingleton();
    }
    
    // 构造器必须显式声明为是私有的，否则外部可以通过构造器创建多个HungrySingleton, 就不是单例模式了
    private HungrySingleton() {}

    public static HungrySingleton getInstance() {
        return hungrySingleton;
    }
}
```

# 懒汉式单例模式
> 确实要使用实例时才创建
* 优点：资源不会被浪费
* 缺点：实现复杂，需要考虑线程安全问题，会被反射攻击，序列化/反序列化不安全
最简单的版本v0.1
```
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    public static LazySingleton getInstance() {
        if (lazySingleton == null) {
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
}
```
这个版本是线程不安全的，如果在未创建lazySingleton的前提条件下，有两个线程同时访问getInstance()。   
两个线程同时进入了if判断并通过，则创建了两个lazySingleton。接下来看两个线程安全的基础版本：   
线程安全的版本1 - v0.2.1:
```
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    // 使用synchronized关键字保证线程安全
    public synchronized static LazySingleton getInstance() {
        if (lazySingleton == null) {
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
}
```
线程安全的版本2 - v0.2.2:
```
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    public static LazySingleton getInstance() {
        synchronized (LazySingleton.class) {
            if (lazySingleton == null) {
                lazySingleton = new LazySingleton();
            }
        }
        return lazySingleton;
    }
}
```
v0.2.1 和 v0.2.2 基本是一样的，使用关键字synchronized保证多线程的唯一访问getInstance()。  
这样就避免了创建多个lazySingleton的可能性。但是又会引入新的问题，即效率极差。   
比如这样一个场景：lazySingleton已经创建好了，并且有无数多个线程要获取这个lazySingleton。  
但是却因为synchronized关键字，每次只能有一个线程访问getInstance()，获取后下一个进程才能访问。  
更不要说算上加锁、解锁的开销了。所以接下来我们要编写一个性能更好的版本，主要优化就是获取lazySingleton这个操作。  

效率更好的线程安全版本 - v0.3:
```
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    public static LazySingleton getInstance() {
        if (lazySingleton == null) {
            synchronized (LazySingleton.class) {
                if (lazySingleton == null) {
                    lazySingleton = new LazySingleton();
                }
            }
        }
        return lazySingleton;
    }
}
```
这个版本常被称为双检查法，if语句不加锁进行判断，避免了锁的开销，效率就大大提升了。  
如果lazySingleton尚未被创建，则再加锁进行判断和创建操作，又避免了多个进程同时进入的问题。  
到此为止，线程安全的问题我们算是解决了，延迟加载的问题也算是解决了。  
但是这个v0.3版本还存在一些非常可怕的隐患，准备下节介绍。  
接下来会编写一些测试方法，来测试这些函数。然后在你们的IDEA中打断点，单步跟踪看看执行的流程吧。

# 测试
> 请针对线程不安全的、线程安全的版本，分别单步测试以上介绍的场景，会吸收得更好。
多线程创建和运行类ThreadT.java：
```
public class ThreadT implements Runnable {
    
    @Override
    public void run() {
        LazySingleton lazySingleton = LazySingleton.getInstance(); // 饿汉式改成HungrySingleton即可
        System.out.println(Thread.currentThread().getName() + " " + instance); // 打印线程名字 和 实例的引用地址
    }
}
```
测试函数类Test.java
```
public class Test {

    public static void main(String[] args) {
        // 使用多线程debug来模拟线程不安全的情况
        Thread t1 = new Thread(new ThreadT());
        Thread t2 = new Thread(new ThreadT());
        t1.start();
        t2.start();
    }
}
```

本节测试也介绍完毕，请针对懒汉单例模式的不同的场景，线程安全性进行测试吧。  
下面介绍jvm的指令重排执行优化带来的可怕隐患。