---
title: 快速排序
date: 2020-03-26 19:47:50
tags: 算法
---
# 快速排序QuickSort
## 未优化的快速排序实现
```
template <typename T>
int partition(T arr[], int lo, int hi)
{
    T pivot_e = arr[lo];

    int j = lo;
    for (int i = lo+1; i <= hi; ++i) {
        if (arr[i] < pivot_e)
            swap(arr[++j], arr[i]);
    }
    swap(arr[lo], arr[j]);
    return j;
}

template <typename T>
void QuickSort(T arr[], int lo, int hi)
{
    if (lo >= hi)
        return;

    int pivot = partition(arr, lo, hi);
    QuickSort(arr, lo, pivot-1);
    QuickSort(arr, pivot+1, hi);
}

template <typename T>
void QuickSort(T arr[], int n)
{
    QuickSort(arr, 0, n-1);
}

Test for random array size = 1073741823, random range [0, 1073741823]
Quick Sort: 400.672 s
```
***
## 复杂度：
1. 时间复杂度：O(nlogn)
2. 空间复杂度：O(1)
***
## 未优化的快速排序算法有什么问题？

### 1. 数组元素较少的情况
#### 解决方案：同归并排序的解决方案，直接转插排

### 2. 近乎有序的数组 —— pivot的选择
#### 问题
partition中pivot默认是lo，pivot_e默认是arr[lo]，对于近乎有序的数组会发生退化到O(n^2)。  
性能测试中对于n=10000,优化后的MergeSort=0.2s，而QuickSort=51s。  
其原因在于**归并排序每次分割出来的数组左右都是平均一样大小的**，而**快速排序是不平均的**。  
在近乎有序的数组中快速排序总是分为两个长度分别为**1**和**n-1**的数组，又递归地对n-1数组进行排序，而n-1的数组又分为**1**和**n-2**的两个数组...  
#### 解决方案
使用随机的pivot，经过数学证明随机的pivot在概率期望的时间复杂度为O(nlogn)。原因是：长度为n的数组，只有1/n的概率pivot=lo，接着又在n-1的数组中只有1/(n-1)的概率pivot=lo，... 也就是说，命中O(n^2)的概率p = n(n-1)(n-2)....1，如果是元素较多的数组中概率p接近于0。而对于普通的随机数组，只是略微变慢但效率保持在一个数量级。

#### 改进方案的代码
```
template <typename T>
int partition2(T arr[], int lo, int hi)
{
	// 优化2：随机选择pivot
    swap(arr[lo], arr[rand()%(hi-lo+1)+lo]);
    T pivot_e = arr[lo];

    int j = lo;
    for (int i = lo+1; i <= hi; ++i) {
        if (arr[i] < pivot_e)
            std::swap(arr[++j], arr[i]);
    }
    swap(arr[lo], arr[j]);
    return j;
}

template <typename T>
void QuickSort2(T arr[], int lo, int hi)
{
	if (hi-lo <= 15) {	// 优化1：元素较少时转插排
		insertion_sort(arr, lo, hi);
		return;
	}

    int pivot = partition2(arr, lo, hi);
    QuickSort2(arr, lo, pivot-1);
    QuickSort2(arr, pivot+1, hi);
}

template <typename T>
void QuickSort2(T arr[], int n)
{
    srand(time(NULL));
    QuickSort2(arr, 0, n-1);
}
```

### 3. 大量重复元素的数组 —— 二路快速排序法
#### 问题
关注这一段代码：
```
for (int i = lo+1; i <= hi; ++i) {
    if (arr[i] < pivot_e)
        std::swap(arr[++j], arr[i]);
}
```
这一段代码是遍历arr全部元素，如果比pivot_e小，则放在未来的pivot的左边，比pivot_e**大或等于**pivot，则放在未来的pivot的右边。  
而问题就在于**等于**又一次导致了**pivot划分两个数组元素不平均**的问题。  
考虑两种情况：  
1. 大量值为v的重复元素比pivot_e小/大 ==> 大量值为v的元素落在pivot分割数组的左边/右边
2. 大量值为v的重复元素和pivot_e相等 ==> 大量值为v的元素落在pivot分割数组的右边  
所以不论怎么样，因为大量的重复元素一定会导致数组变得失衡（除非有成对的且基本一样多的值为v1,v2的元素正好落在pivot的两侧）。  
#### 解决方案
二路排序法通过**雨露均沾**的想法，左侧可以有一定机会获得和pivot_e相等的元素，右侧也可以有一定机会获得和pivot_e相等的元素，这样就可以保证每次通过pivot分割出来的两个数组元素数量尽可能接近，不会有非常失衡的情况出现。最后pivot就区分出了两个分区，arr[lo, pivot-1] <= pivot_e 和 arr[pivot+1, hi] >= pivot_e。  
接下来给出这个代码的两种版本，一种是严蔚敏老师的，一种是bobo老师的，严版的代码更简洁漂亮，整体效率更好，而bobo老师的简单易懂。  
#### 改进方案的代码
严：
```
template <typename T>
int partition2Ways(T arr[], int lo, int hi)
{
    swap(arr[lo], arr[rand()%(hi-lo+1)+lo]);
    T pivot_e = arr[lo];
    while (lo < hi) {
        while (lo < hi && arr[hi] >= pivot_e) --hi;
        arr[lo] = arr[hi];
        while (lo < hi && arr[lo] <= pivot_e) ++lo;
        arr[hi] = arr[lo];
    }
    arr[lo] = pivot_e;
    return lo;
}

template <typename T>
void QuickSort2Ways(T arr[], int lo, int hi)
{
	if (hi-lo <= 15) {
		insertion_sort(arr, lo, hi);
		return;
	}
    int pivot = partition2Ways(arr, lo, hi);
    
    QuickSort2Ways(arr, lo, pivot-1);
    QuickSort2Ways(arr, pivot+1, hi);
}



Test for random array, size = 1073741823, random range [0, 1073741823]
Quick Sort: 257.516 s

Test for nearly ordered array, size = 1073741823, swap time = 100
Quick Sort: 125.25 s

Test for random array, size = 1073741823, random range [0,10]
^C (包含大量重复元素的测试数据，跑了差不多2小时但没有结果)

未加随机pivot优化的严版快速二路排序算法：
Test for random array size = 1073741823, random range [0, 1073741823]
Quick Sort: 225.75 s
```
bobo:
```
template <typename T>
int partition2Ways(T arr[], int lo, int hi)
{
    std::swap(arr[lo], arr[rand()%(hi-lo+1)+lo]);
    T pivot_e = arr[lo];

    int i = lo+1, j = hi;
    while (true) {
        while (i <= hi && arr[i] < pivot_e) ++i;
        while (j >= lo+1 && arr[j] > pivot_e) --j;
        if (i > j) break;
        std::swap(arr[i++], arr[j--]);
    }
}

template <typename T>
void QuickSort2Ways(T arr[], int lo, int hi)
{
	if (hi-lo <= 15) {
		insertion_sort(arr, lo, hi);
		return;
	}
    int pivot = partition2(arr, lo, hi);
    QuickSort2Ways(arr, lo, pivot-1);
    QuickSort2Ways(arr, pivot+1, hi);
}

template <typename T>
void QuickSort2Ways(T arr[], int n)
{
    srand(time(nullptr));
    QuickSort2Ways(arr, 0, n-1);
}

Test for random array, size = 1073741823, random range [0, 1073741823]
Quick Sort: 419.562 s

Test for nearly ordered array, size = 1073741823, swap time = 100
Quick Sort: 305.734 s

Test for random array, size = 999999, random range [0,10]
Quick Sort: 105.688 s （包含大量重复元素的测试数据，只有100万个测试元素）
```
### 3. 更好的大量重复元素的解决方案 —— 三路快速排序法
#### 问题
从二路快速排序算法的测试结果中可以看出，在面对大量重复元素的10亿个左右的测试数据下，使用了2个小时仍然无法有正确的排序返回结果。而在100万个包含大量重复元素的测试数据情况下，也需要和10亿个完全随机元素差不多的时间才能有正确结果。  
当面对大量重复元素的时候，二路快速排序法虽然好，但是需要多次对pivot分割出来的含有重复且相等的元素的两个数组arr[lo, pivot-1] <= pivot_e 和 arr[pivot+1, hi] >= pivot_e进行递归快排,有没有什么办法一下子可以把所有重复的元素剔除出来以减少两个数组的大小和递归的次数呢？
#### 解决方案
当面对大量重复元素的时候，二路快速排序法选择分为两个区间，arr[lo, pivot-1] <= pivot_e 和 arr[pivot+1, hi] >= pivot_e。  
而三路快速排序法选择分为三个区间：arr[lo, pivot_left-1] < pivot_e , arr[pivot_left, pivot_right] == pivot_e , arr[pivot_right+1, hi] > pivot_e。  
通过这种方法就剔除出所有等于pivot_e的元素，减少了递归的次数。  
注：对于以下提供的程序代码来说，三个区间分别是arr[lo, lt-1] < pivot_e , arr[lt, gt-1] == pivot_e , arr[gt, hi] > pivot_e。如果有疑惑可以看bobo老师视频演示动画。  
#### 改进方案的代码
自己写的：
```
template <typename T>
void QuickSort3Ways2(T arr[], int lo, int hi)
{
    if (hi-lo <= 15) {
        insertionSort(arr, lo, hi);
        return;
    }

    swap(arr[lo], arr[rand()%(hi-lo+1)+lo]);
    T pivot_e = arr[lo];
    int lt = lo, i = lo+1, gt = hi+1;
    while (i < gt) {
        while (i < gt && arr[i] < pivot_e) swap(arr[i++], arr[++lt]);
        while (i < gt && arr[i] > pivot_e) swap(arr[i], arr[--gt]);
        while (i < gt && arr[i] == pivot_e) ++i;
    }
    swap(arr[lo], arr[lt]);
    QuickSort3Ways2(arr, lo, lt-1);
    QuickSort3Ways2(arr, gt, hi);
}

template <typename T>
void QuickSort3Ways2(T arr[], int n)
{
    srand(time(nullptr));
    QuickSort3Ways2(arr, 0, n-1);
}

```
bobo版：
```
template <typename T>
void QuickSort3Ways1(T arr[], int lo, int hi)
{
    if (hi-lo <= 15) {
        insertionSort(arr, lo, hi);
        return;
    }

    swap(arr[lo], arr[rand()%(hi-lo+1)+lo]);
    T pivot_e = arr[lo];
    int lt = lo; // 排序过程中lt 指向最后一个 < pivot_e的元素
    int gt = hi+1; // gt 指向第一个 > pivot_e的元素
    int i = lo+1; // i 指向将要与 pivot_e比较的元素
    while (i < gt) {
        if (arr[i] < pivot_e)
            swap(arr[i++], arr[++lt]);
        else if (arr[i] > pivot_e)
            swap(arr[i], arr[--gt]);
        else
            ++i;
    }

    swap(arr[lo], arr[lt]); // 排好序lt 指向第一个 == pivot_e的元素
    QuickSort3Ways1(arr, lo, lt-1);
    QuickSort3Ways1(arr, gt, hi);
}

template <typename T>
void QuickSort3Ways1(T arr[], int n)
{
	srand(time(nullptr));
    QuickSort3Ways1(arr, 0, n-1);
}


Test for random array, size = 1073741823, random range [0, 1073741823]
Quick Sort: 527.094 s (完全随机元素速度在10亿量级减慢了100s左右，完全可以接受)

Test for nearly ordered array, size = 1073741823, swap time = 100
Quick Sort: 442.156 s

Test for random array, size = 1073741823, random range [0,10]
Quick Sort: 46.9531 s (太强了，对于大量重复元素的情况提升巨大)
```
这里附上两个版本的测试对比：
```
Test for random array, size = 1073741823, random range [0, 1073741823]
QuickSort3Ways1 : 143.312 s
QuickSort3Ways2: 138.672 s

Test for nearly ordered array, size = 1073741823, swap time = 100
QuickSort3Ways1: : 51.5312 s
QuickSort3Ways2: 45.8594 s

Test for random array, size = 1073741823, random range [0,10]
QuickSort3Ways1: : 16.2188 s
QuickSort3Ways2: 15.3281 s
```
***
## 小记：我的错误优化
未优化的严蔚敏版快速排序算法，这里我测试了两种，一种是标准代码，一种是我错误的优化代码，分别如下：  
```
template <typename T>
int partition(T arr[], int lo, int hi)
{
    T pivot_e = arr[lo];
    while (lo < hi) {
        while (lo < hi && arr[hi] >= pivot_e) --hi;
        arr[lo] = arr[hi];
        while (lo < hi && arr[lo] <= pivot_e) ++lo;
        arr[hi] = arr[lo];
    }
    arr[lo] = pivot_e;
    return lo;
}

template <typename T>
void QuickSort(T arr[], int lo, int hi)
{
	if (hi-lo <= 15) {
		insertion_sort(arr, lo, hi);
	    return;
	}

    int pivot = partition(arr, lo, hi);
    
    QuickSort(arr, lo, pivot-1);
    QuickSort(arr, pivot+1, hi);
}


Test for random array size = 1073741823, random range [0, 1073741823]
Quick Sort: 225.75 s
```
```
template <typename T>
void QuickSort(T arr[], int lo, int hi)
{
    if (lo >= hi)
        return;

    int pivot = partition(arr, lo, hi);
    
    if (lo < pivot-1) QuickSort(arr, lo, pivot-1);
    if (pivot+1 < hi) QuickSort(arr, pivot+1, hi);
}

Test for random array size = 1073741823, random range [0, 1073741823]
Quick Sort: 231.484 s
```
我认为这个优化最主要的问题在于if语句，它减少了指令流水和编译器对代码的优化。应该要尽可能避免if语句而使用while,for循环语句，可以增加程序的并行性。  
至少可以说明为了减少函数跳用而增加多余的if语句对代码执行速度没有显著提升，所以不要进行过早的或多余的优化，除非这个优化可以在复杂度上有显著提升。  